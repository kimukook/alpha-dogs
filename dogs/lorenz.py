#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Oct 31 18:06:47 2017

@author: mousse
"""

import numpy as np
import scipy.io as io

'''
lorenz.py file provides an figures of the implementation of DeltaDOGS on lorenz system:
  dx/dt = sigma * (y - x)
  dy/dt = x * (rho - z) - y
  dz/dt = x * y - beta * z
Here we define the 1D lorenz problem by finding the optimal parameter rho such that the mean of horizontal temperature variation, 
y, is equal to 23.5317.
2D lorenz problem is defined by finding the optimal parameters rho and beta to satisfy the mean and variation of y will be 
equal to .
'''
####################################### Lorenz ###################################################


class Lorenz:
    def __init__(self, dimension, x, T, h, y0, idx, eval_type):
        x = x.reshape(-1, 1)
        self.n = dimension
        self.param = x
        self.T = T
        self.h = h
        self.y0 = y0
        self.idx = idx
        self.eval_type = eval_type
        self.x = None
        self.states_assemble()

    def states_assemble(self):
        s0 = np.array([[10]])
        # r0 = np.array([[28]])
        b0 = np.array([[2.667]])

        if self.n == 1:
            self.x = np.vstack((s0, self.param, b0))
        elif self.n == 2:
            self.x = np.vstack((s0, self.param))
        else:
            self.x = np.copy(self.param)
            ValueError("Only 1D and 2D input in lorenz work.")

    def RK4_timemarch(self, x_states):
        '''
        This is an implementation of the fourth-order Runge-Kutta method
        to solve systems of ODEs.
        :param x_states: the current state
        :return: the time marched point
        '''
        f1 = self.lorenz(x_states)
        f2 = self.lorenz(x_states + self.h / 2 * f1)
        f3 = self.lorenz(x_states + self.h / 2 * f2)
        f4 = self.lorenz(x_states + self.h * f3)
        return x_states + self.h / 6 * (f1 + 2 * f2 + 2 * f3 + f4)

    def lorenz(self, x_state):
        '''
        Return the derivative generated by lorenz system
        :param x_state: the current state
        :return:
        '''
        x_dot = np.empty((3,))
        x_dot[0] = self.x[0] * (x_state[1] - x_state[0])
        x_dot[1] = self.x[1] * x_state[0] - x_state[1] - x_state[0] * x_state[2]
        x_dot[2] = x_state[0] * x_state[1] - self.x[2] * x_state[2]
        return x_dot

    def lorenz_eval(self):
        stepCnt = int(self.T / self.h)
        xs, ys, zs = [np.zeros(stepCnt) for _ in range(3)]

        if self.eval_type == 'identify':  # This is the First time sampling at x.
            # start a new simulation, setting initial values
            xs0, ys0, zs0 = [np.empty(shape=[1, ]) for _ in range(3)]
            xs[0] = 0
            ys[0] = 1
            zs[0] = 1.05

        else:
            pt = io.loadmat('AllPoints/pt_to_eval' + str(self.idx) + '.mat')
            xs0 = pt['xs'][0]
            xs[0] = xs0[-1]
            ys0 = pt['ys'][0]
            ys[0] = ys0[-1]
            zs0 = pt['zs'][0]
            zs[0] = zs0[-1]

        # RK4
        for i in range(stepCnt - 1):
            X = np.hstack((xs[i], ys[i], zs[i]))
            x1 = self.RK4_timemarch(X)
            xs[i + 1] = x1[0]
            ys[i + 1] = x1[1]
            zs[i + 1] = x1[2]

        if self.eval_type != 'identify':
            xs = np.hstack((xs0, xs[1:]))
            ys = np.hstack((ys0, ys[1:]))
            zs = np.hstack((zs0, zs[1:]))

        if self.n == 1:
            J = np.abs(np.mean(zs) - self.y0)

        elif self.n == 2:
            J = (np.sum(((np.mean(zs) - self.y0[0]) ** 2, (np.std(zs) - self.y0[1]) ** 2))) / len(self.y0)

        else:
            J = (np.sum(((np.mean(zs) - self.y0[0]) ** 2, (np.std(zs) - self.y0[1]) ** 2))) / len(self.y0)

        return J, zs, xs, ys



    # ==============  Lorenz test case  ==============

    def lorenz_solver(self, x, t):
        x = x.reshape(-1, 1)
        val, idx, xmin = Utils.mindis(x, self.xE)
        # Transform back to physical bounds
        x_eval = Utils.physical_bounds(x, self.physical_lb, self.physical_ub)

        s0 = np.array([[10]])
        # r0 = np.array([[28]])
        b0 = np.array([[2.667]])

        if self.n == 1:
            x0 = np.vstack((s0, x_eval, b0))
        elif self.n == 2:
            x0 = np.vstack((s0, x_eval))
        else:
            x0 = np.copy(x_eval)
            ValueError("Only 1D and 2D input in lorenz work.")

        h = 0.005
        y0 = 23.5712
        if self.iter_type == 'sdmin':
            eval_type = 'additional'
        else:
            eval_type = 'identify'
        current_lorenz = lorenz.Lorenz(self.n, x0, t, h, y0, idx, eval_type)
        J, zs, xs, ys = current_lorenz.lorenz_eval()

        # Store the data

        data_out = {'zs': zs, 'xs': xs, 'ys': ys,
                    'J' : J , 'h' : h , 'T' : t  }

        if not self.initial_prior:
            path = "AllPoints/pt_to_eval" + str(idx) + '.mat'
            io.savemat(path, data_out)
        else:
            pass

        return J

    def lorenz_sigma_solver(self, x, t):
        x = x.reshape(-1, 1)
        val, idx, xmin = Utils.mindis(x, self.xE)
        if self.initial_prior:  # Only for prior we need to re-run Lorenz
            x_eval = Utils.physical_bounds(x, self.physical_lb, self.physical_ub)

            s0 = np.array([[10]])
            # r0 = np.array([[28]])
            b0 = np.array([[2.667]])

            if self.n == 1:
                x0 = np.vstack((s0, x_eval, b0))
                y0 = 23.5712
            elif self.n == 2:
                y0 = 23.5712
                x0 = np.vstack((s0, x_eval))
            else:
                y0 = 23.5712
                x0 = np.copy(x_eval)
                ValueError("Only 1D and 2D input in lorenz work.")
            t = self.T0
            h = 0.005 * 2
            eval_type = 'identify'
            current_lorenz = lorenz.Lorenz(self.n, x0, self.T0, h, y0, idx, eval_type)
            J, zs, xs, ys = current_lorenz.lorenz_eval()

        else:  # re-load evaluated data file
            data = io.loadmat("AllPoints/pt_to_eval" + str(idx) + '.mat')
            t = data['T'][0, 0]
            h = data['h'][0, 0]
            zs = data['zs'][0]

        length = int(min((t/h)/5, 40))
        xx = uq.data_moving_average(zs, length)
        sig = np.sqrt(uq.stationary_statistical_learning_reduced(xx, 18)[0])
        return sig
