#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Oct 31 18:06:47 2017

@author: mousse
"""

import numpy as np
import scipy.io as io
from lorenz import uq
import os

'''
lorenz.py file provides an figures of the implementation of DeltaDOGS on lorenz system:
  dx/dt = sigma * (y - x)
  dy/dt = x * (rho - z) - y
  dz/dt = x * y - beta * z
Here we define the 1D lorenz problem by finding the optimal parameter rho such that the mean of horizontal temperature variation, 
y, is equal to 23.5317.
2D lorenz problem is defined by finding the optimal parameters rho and beta to satisfy the mean and variation of y will be 
equal to .
'''
####################################### Lorenz ###################################################


class Lorenz:
    def __init__(self, x, T, h, y0, idx, eval_type):
        x = x.reshape(-1, 1)
        self.n = x.shape[0]
        self.param = x
        self.T = T
        self.h = h
        self.y0 = y0
        self.idx = idx
        self.eval_type = eval_type
        self.x = None
        self.states_assemble()

        self.J = None
        self.xs = None
        self.ys = None
        self.zs = None
        self.sig = None

    def states_assemble(self):
        s0 = np.array([[10]])
        # r0 = np.array([[28]])
        b0 = np.array([[2.667]])

        if self.n == 1:
            self.x = np.vstack((s0, self.param, b0))
        elif self.n == 2:
            self.x = np.vstack((s0, self.param))
        else:
            self.x = np.copy(self.param)
            ValueError("Only 1D and 2D input in lorenz work.")

    def RK4_timemarch(self, x_states):
        '''
        This is an implementation of the fourth-order Runge-Kutta method
        to solve systems of ODEs.
        :param x_states: the current state
        :return: the time marched point
        '''
        f1 = self.lorenz(x_states)
        f2 = self.lorenz(x_states + self.h / 2 * f1)
        f3 = self.lorenz(x_states + self.h / 2 * f2)
        f4 = self.lorenz(x_states + self.h * f3)
        return x_states + self.h / 6 * (f1 + 2 * f2 + 2 * f3 + f4)

    def lorenz(self, x_state):
        '''
        Return the derivative generated by lorenz system
        :param x_state: the current state
        :return:
        '''
        x_dot = np.empty((3,))
        x_dot[0] = self.x[0] * (x_state[1] - x_state[0])
        x_dot[1] = self.x[1] * x_state[0] - x_state[1] - x_state[0] * x_state[2]
        x_dot[2] = x_state[0] * x_state[1] - self.x[2] * x_state[2]
        return x_dot

    def lorenz_eval(self):
        stepCnt = int(self.T / self.h)
        xs, ys, zs = [np.zeros(stepCnt) for _ in range(3)]

        if self.eval_type == 'identify':  # This is the First time sampling at x.
            # start a new simulation, setting initial values
            xs[0] = 0
            ys[0] = 1
            zs[0] = 1.05

        else:
            pt = io.loadmat('AllPoints/pt' + str(self.idx) + '.mat')
            xs0 = pt['xs'][0]
            xs[0] = xs0[-1]
            ys0 = pt['ys'][0]
            ys[0] = ys0[-1]
            zs0 = pt['zs'][0]
            zs[0] = zs0[-1]

        # RK4
        for i in range(stepCnt - 1):
            X = np.hstack((xs[i], ys[i], zs[i]))
            x1 = self.RK4_timemarch(X)
            xs[i + 1] = x1[0]
            ys[i + 1] = x1[1]
            zs[i + 1] = x1[2]

        if self.eval_type == 'identify':
            xs = np.hstack((0, xs[1:]))
            ys = np.hstack((1, ys[1:]))
            zs = np.hstack((1.05, zs[1:]))

        else:
            xs = np.hstack((xs0, xs[1:]))
            ys = np.hstack((ys0, ys[1:]))
            zs = np.hstack((zs0, zs[1:]))

        if self.n == 1:
            J = np.abs(np.mean(zs) - self.y0)

        elif self.n == 2:
            J = (np.sum(((np.mean(zs) - self.y0[0]) ** 2, (np.std(zs) - self.y0[1]) ** 2))) / len(self.y0)

        else:
            J = (np.sum(((np.mean(zs) - self.y0[0]) ** 2, (np.std(zs) - self.y0[1]) ** 2))) / len(self.y0)

        print(f'Params = {self.param}, J = {J}')
        self.J = np.copy(J)
        self.xs = np.copy(xs)
        self.ys = np.copy(ys)
        self.zs = np.copy(zs)

        data = {'xs': xs,
                'ys': ys,
                'zs': zs}
        path = os.path.join(os.getcwd(), 'AllPoints/pt' + str(self.idx) + '.mat')
        io.savemat(path, data)

    def uncertainty_calculator(self):
        length = int(min((self.T/self.h)/5, 1000))
        xx = uq.data_moving_average(self.zs, length)
        self.sig = np.sqrt(uq.stationary_statistical_learning_reduced(xx.reshape(-1, 1).T, 18)[0])

    def main(self):
        self.lorenz_eval()
        self.uncertainty_calculator()
        return self.J, self.sig
